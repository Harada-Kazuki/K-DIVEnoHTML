<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ë¶ñËÅ¥ËÄÖ | WebRTC Viewer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    background: #0a0a0a;
    color: #d4c5aa;
    font-family: 'Orbitron', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 30px 20px;
    position: relative;
    overflow-x: hidden;
  }
  
  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      linear-gradient(90deg, transparent 0%, rgba(212, 197, 170, 0.03) 50%, transparent 100%),
      repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(212, 197, 170, 0.05) 2px, rgba(212, 197, 170, 0.05) 4px);
    pointer-events: none;
    z-index: 0;
  }
  
  .container {
    position: relative;
    z-index: 1;
    max-width: 1000px;
    width: 100%;
  }
  
  h1 {
    font-size: 2.5em;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 4px;
    margin-bottom: 10px;
    text-shadow: 0 0 20px rgba(212, 197, 170, 0.5);
    border-left: 4px solid #d4c5aa;
    padding-left: 20px;
  }
  
  .subtitle {
    font-size: 0.9em;
    color: #8a8174;
    margin-bottom: 30px;
    padding-left: 24px;
    letter-spacing: 2px;
  }
  
  #status {
    display: inline-block;
    padding: 12px 30px;
    margin: 20px 0;
    border: 2px solid #d4c5aa;
    background: rgba(10, 10, 10, 0.8);
    font-size: 0.9em;
    letter-spacing: 2px;
    text-transform: uppercase;
    position: relative;
    clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
  }
  
  .status-disconnected { 
    border-color: #555;
    color: #555;
  }
  .status-connecting { 
    border-color: #ff9f43;
    color: #ff9f43;
    box-shadow: 0 0 20px rgba(255, 159, 67, 0.3);
    animation: pulse 1.5s infinite;
  }
  .status-connected { 
    border-color: #d4c5aa;
    color: #d4c5aa;
    box-shadow: 0 0 20px rgba(212, 197, 170, 0.4);
  }
  .status-error { 
    border-color: #ff6b6b;
    color: #ff6b6b;
    box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
  }
  .status-waiting { 
    border-color: #5ac8fa;
    color: #5ac8fa;
    box-shadow: 0 0 20px rgba(90, 200, 250, 0.3);
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }
  
  #remote {
    width: 100%;
    max-width: 900px;
    background: #000;
    margin: 30px auto;
    border: 3px solid #d4c5aa;
    box-shadow: 
      0 0 30px rgba(212, 197, 170, 0.2),
      inset 0 0 50px rgba(0, 0, 0, 0.5);
    clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
  }
  
  .controls {
    display: flex;
    gap: 20px;
    justify-content: center;
    margin: 30px 0;
    flex-wrap: wrap;
  }
  
  button {
    padding: 15px 40px;
    font-size: 0.95em;
    font-family: 'Orbitron', monospace;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
    border: 2px solid #d4c5aa;
    background: rgba(10, 10, 10, 0.9);
    color: #d4c5aa;
    cursor: pointer;
    transition: all 0.3s;
    clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
    position: relative;
  }
  
  button::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, transparent, rgba(212, 197, 170, 0.2), transparent);
    clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
    opacity: 0;
    transition: opacity 0.3s;
    z-index: -1;
  }
  
  button:hover:not(:disabled)::before {
    opacity: 1;
  }
  
  button:hover:not(:disabled) {
    background: rgba(212, 197, 170, 0.1);
    box-shadow: 0 0 20px rgba(212, 197, 170, 0.3);
    transform: translateY(-2px);
  }
  
  button:disabled {
    border-color: #333;
    color: #333;
    cursor: not-allowed;
    background: rgba(10, 10, 10, 0.5);
  }
  
  .debug-info {
    margin-top: 40px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid #333;
    font-size: 11px;
    text-align: left;
    max-width: 900px;
    margin-left: auto;
    margin-right: auto;
    font-family: 'Courier New', monospace;
    color: #8a8174;
    clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
    max-height: 300px;
    overflow-y: auto;
  }
  
  .debug-info::-webkit-scrollbar {
    width: 8px;
  }
  
  .debug-info::-webkit-scrollbar-track {
    background: #0a0a0a;
  }
  
  .debug-info::-webkit-scrollbar-thumb {
    background: #333;
    border-radius: 4px;
  }
  
  .debug-info strong {
    color: #d4c5aa;
    font-size: 12px;
    letter-spacing: 2px;
    display: block;
    margin-bottom: 10px;
  }
</style>
</head>
<body>
<div class="container">
  <h1>üì± Viewer</h1>
  <p class="subtitle">WebRTC Stream Receiver</p>

  <div id="status" class="status-disconnected">System Offline</div>

  <video id="remote" autoplay playsinline></video>

  <div class="controls">
    <button id="connectBtn">Connect & Watch</button>
  </div>

  <div class="debug-info">
    <strong>// System Log</strong>
    <div id="debugLog"></div>
  </div>
</div>

<script>
const WS_URL = "wss://k-divenohtml.onrender.com";

const ICE_SERVERS = [
  { urls: 'stun:stun.l.google.com:19302' },
  { urls: 'stun:stun1.l.google.com:19302' },
  { urls: 'stun:stun2.l.google.com:19302' },
  {
    urls: 'turn:openrelay.metered.ca:80',
    username: 'openrelayproject',
    credential: 'openrelayproject'
  },
  {
    urls: 'turn:openrelay.metered.ca:443',
    username: 'openrelayproject',
    credential: 'openrelayproject'
  }
];

let ws = null;
let pc = null;
let reconnectInterval = null;
let myViewerId = null;

const statusDiv = document.getElementById('status');
const connectBtn = document.getElementById('connectBtn');
const video = document.getElementById('remote');
const debugLog = document.getElementById('debugLog');

function log(msg) {
  console.log(msg);
  const time = new Date().toLocaleTimeString();
  debugLog.innerHTML = `[${time}] ${msg}<br>` + debugLog.innerHTML;
  const lines = debugLog.innerHTML.split('<br>');
  if (lines.length > 30) {
    debugLog.innerHTML = lines.slice(0, 30).join('<br>');
  }
}

function updateStatus(text, className) {
  const statusMap = {
    '„Çµ„Éº„Éê„Éº„Å´Êé•Á∂ö‰∏≠...': 'Connecting to Server...',
    'ÈÖç‰ø°ÂæÖÊ©ü‰∏≠...': 'Waiting for Broadcast...',
    'ÈÖç‰ø°„Å´Êé•Á∂ö‰∏≠...': 'Connecting to Stream...',
    '‚úÖ Ë¶ñËÅ¥‰∏≠': '[ STREAMING ]',
    'ÈÖç‰ø°„ÅåÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü': 'Broadcast Ended',
    'Êé•Á∂ö„Åå‰∏çÂÆâÂÆö„Åß„Åô': 'Connection Unstable',
    'Êé•Á∂ö„ÅåÂàá„Çå„Åæ„Åó„Åü': 'Connection Lost',
    'ÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü': 'Disconnected',
    'Êé•Á∂ö„Ç®„É©„Éº': 'Connection Error'
  };
  statusDiv.textContent = statusMap[text] || text;
  statusDiv.className = className;
}

function connectWebSocket() {
  if (ws && ws.readyState === WebSocket.OPEN) return;
  
  updateStatus('„Çµ„Éº„Éê„Éº„Å´Êé•Á∂ö‰∏≠...', 'status-connecting');
  log('üîÑ WebSocketÊé•Á∂ö„ÇíË©¶Ë°å‰∏≠...');
  ws = new WebSocket(WS_URL);
  
  ws.onopen = () => {
    log('‚úÖ WebSocketÊé•Á∂öÊàêÂäü');
    updateStatus('ÈÖç‰ø°ÂæÖÊ©ü‰∏≠...', 'status-waiting');
    
    if (reconnectInterval) {
      clearInterval(reconnectInterval);
      reconnectInterval = null;
    }
    
    // Ë¶ñËÅ¥ËÄÖ„Å®„Åó„Å¶ÁôªÈå≤
    log('üì§ Ë¶ñËÅ¥ËÄÖ„Å®„Åó„Å¶ÁôªÈå≤');
    ws.send(JSON.stringify({ viewer: true }));
  };
  
  ws.onmessage = async (e) => {
    try {
      const msg = JSON.parse(e.data);
      
      // ÁôªÈå≤ÂÆå‰∫Ü
      if (msg.type === 'registered' && msg.role === 'viewer') {
        myViewerId = msg.viewerId;
        log(`‚úÖ Ë¶ñËÅ¥ËÄÖID„ÇíÂèñÂæó: ${myViewerId}`);
      }
      
      // ÈÖç‰ø°ÁµÇ‰∫Ü
      else if (msg.type === 'broadcasterDisconnected') {
        log('üõë ÈÖç‰ø°„ÅåÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü');
        updateStatus('ÈÖç‰ø°„ÅåÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü', 'status-error');
        if (pc) {
          pc.close();
          pc = null;
        }
        video.srcObject = null;
        connectBtn.disabled = false;
      }
      
      // ÈÖç‰ø°ËÄÖ„Åã„Çâ„ÅÆOffer
      else if (msg.type === 'offer') {
        log('üì• ÈÖç‰ø°ËÄÖ„Åã„ÇâOffer„ÇíÂèó‰ø°');
        updateStatus('ÈÖç‰ø°„Å´Êé•Á∂ö‰∏≠...', 'status-connecting');
        
        // PeerConnection‰ΩúÊàê
        if (pc) pc.close();
        pc = new RTCPeerConnection({ 
          iceServers: ICE_SERVERS,
          iceCandidatePoolSize: 10,
          bundlePolicy: 'max-bundle',
          rtcpMuxPolicy: 'require'
        });
        log('üîó PeerConnection‰ΩúÊàê');
        
        // „É™„É¢„Éº„Éà„Çπ„Éà„É™„Éº„É†Âèó‰ø°
        pc.ontrack = (e) => {
          log('üì∫ Êò†ÂÉè„Éà„É©„ÉÉ„ÇØ„ÇíÂèó‰ø°');
          log(`üì∫ „Éà„É©„ÉÉ„ÇØÊÉÖÂ†±: kind=${e.track.kind}, enabled=${e.track.enabled}, readyState=${e.track.readyState}`);
          
          if (video.srcObject !== e.streams[0]) {
            video.srcObject = e.streams[0];
            log('‚úÖ „Éì„Éá„Ç™„ÇΩ„Éº„ÇπË®≠ÂÆöÂÆå‰∫Ü');
          }
          
          updateStatus('‚úÖ Ë¶ñËÅ¥‰∏≠', 'status-connected');
        };
        
        // ICEÂÄôË£ú„ÅÆÂá¶ÁêÜ
        pc.onicecandidate = (e) => {
          if (e.candidate && ws && ws.readyState === WebSocket.OPEN) {
            log('üßä ICEÂÄôË£ú„ÇíÈÖç‰ø°ËÄÖ„Å´ÈÄÅ‰ø°');
            ws.send(JSON.stringify({ 
              candidate: e.candidate,
              viewerId: myViewerId
            }));
          } else if (!e.candidate) {
            log('‚úÖ ICEÂÄôË£ú„ÅÆÂèéÈõÜÂÆå‰∫Ü');
          }
        };
        
        pc.oniceconnectionstatechange = () => {
          const state = pc.iceConnectionState;
          log(`üîÑ ICEÊé•Á∂öÁä∂ÊÖã: ${state}`);
          
          if (state === 'connected' || state === 'completed') {
            updateStatus('‚úÖ Ë¶ñËÅ¥‰∏≠', 'status-connected');
          } else if (state === 'disconnected') {
            log('‚ö†Ô∏è ‰∏ÄÊôÇÁöÑ„Å´ÂàáÊñ≠');
            updateStatus('Êé•Á∂ö„Åå‰∏çÂÆâÂÆö„Åß„Åô', 'status-error');
          } else if (state === 'failed') {
            log('‚ùå ICEÊé•Á∂öÂ§±Êïó');
            updateStatus('Êé•Á∂ö„ÅåÂàá„Çå„Åæ„Åó„Åü', 'status-error');
            video.srcObject = null;
          }
        };
        
        pc.onconnectionstatechange = () => {
          log(`üîÑ PeerConnectionÁä∂ÊÖã: ${pc.connectionState}`);
        };
        
        // OfferË®≠ÂÆö„Å®Answer‰ΩúÊàê
        log('üìù RemoteDescription„ÇíË®≠ÂÆö');
        await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
        
        log('üìù Answer‰ΩúÊàê‰∏≠...');
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        log('‚úÖ LocalDescriptionË®≠ÂÆöÂÆå‰∫Ü');
        
        // Answer„ÇíÈÄÅ‰ø°
        if (ws && ws.readyState === WebSocket.OPEN && myViewerId) {
          log('üì§ Answer„ÇíÈÖç‰ø°ËÄÖ„Å´ÈÄÅ‰ø°');
          ws.send(JSON.stringify({ 
            answer,
            viewerId: myViewerId
          }));
        }
        
        connectBtn.disabled = true;
      }
      
      // ÈÖç‰ø°ËÄÖ„Åã„Çâ„ÅÆICEÂÄôË£ú
      else if (msg.type === 'candidate' && pc) {
        log('üßä ÈÖç‰ø°ËÄÖ„Åã„ÇâICEÂÄôË£ú„ÇíÂèó‰ø°');
        await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
      }
      
    } catch (err) {
      log('‚ùå „É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜ„Ç®„É©„Éº: ' + err.message);
      updateStatus('„Ç®„É©„Éº: ' + err.message, 'status-error');
    }
  };
  
  ws.onerror = (err) => {
    log('‚ùå WebSocket„Ç®„É©„Éº');
    updateStatus('Êé•Á∂ö„Ç®„É©„Éº', 'status-error');
  };
  
  ws.onclose = () => {
    log('üîå WebSocketÂàáÊñ≠');
    updateStatus('ÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü', 'status-disconnected');
    connectBtn.disabled = false;
    
    if (!reconnectInterval) {
      reconnectInterval = setInterval(() => {
        log('üîÑ Ëá™ÂãïÂÜçÊé•Á∂ö„ÇíË©¶Ë°å...');
        connectWebSocket();
      }, 3000);
    }
  };
}

connectBtn.onclick = () => {
  connectWebSocket();
};

window.addEventListener('beforeunload', () => {
  if (pc) pc.close();
  if (ws) ws.close();
});

// Ëá™ÂãïÊé•Á∂ö„ÅØ„Åó„Å™„ÅÑ
log('üöÄ Ë¶ñËÅ¥ËÄÖ„Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü');
</script>
</body>
</html>
