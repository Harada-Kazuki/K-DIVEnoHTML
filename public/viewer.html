<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>è¦–è´è€… | WebRTC Viewer</title>
<style>
  body {
    background: #111;
    color: #eee;
    text-align: center;
    font-family: sans-serif;
    margin: 0;
    padding: 20px;
  }
  #remote {
    width: 90%;
    max-width: 800px;
    border-radius: 12px;
    background: #000;
    margin: 20px auto;
  }
  button {
    padding: 12px 30px;
    font-size: 16px;
    border-radius: 8px;
    border: none;
    background: #2196F3;
    color: white;
    cursor: pointer;
    margin: 10px;
  }
  button:disabled {
    background: #666;
    cursor: not-allowed;
  }
  button:hover:not(:disabled) {
    background: #0b7dda;
  }
  #status {
    margin: 20px;
    padding: 10px;
    border-radius: 8px;
    display: inline-block;
  }
  .status-disconnected { background: #666; }
  .status-connecting { background: #FF9800; }
  .status-connected { background: #4CAF50; }
  .status-error { background: #f44336; }
  .status-waiting { background: #9C27B0; }
</style>
</head>
<body>
<h1>ğŸ“± è¦–è´ãƒšãƒ¼ã‚¸</h1>

<div id="status" class="status-disconnected">æœªæ¥ç¶š</div>

<video id="remote" autoplay playsinline></video>

<div>
  <button id="connectBtn">æ¥ç¶šã—ã¦è¦–è´</button>
</div>

<script>
const WS_URL = "wss://k-divenohtml.onrender.com"; // Renderã®WebSocket URLã«ç½®ãæ›ãˆ
const ICE_SERVERS = [
  { urls: 'stun:stun.l.google.com:19302' },
  { urls: 'stun:stun1.l.google.com:19302' }
];

let ws = null;
let pc = null;
let reconnectInterval = null;

const statusDiv = document.getElementById('status');
const connectBtn = document.getElementById('connectBtn');
const video = document.getElementById('remote');

function updateStatus(text, className) {
  statusDiv.textContent = text;
  statusDiv.className = className;
}

function connectWebSocket() {
  if (ws && ws.readyState === WebSocket.OPEN) return;

  updateStatus('ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šä¸­...', 'status-connecting');
  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    console.log('ğŸŒ WebSocket connected');
    updateStatus('é…ä¿¡å¾…æ©Ÿä¸­...', 'status-waiting');

    if (reconnectInterval) {
      clearInterval(reconnectInterval);
      reconnectInterval = null;
    }

    // ğŸ‘€ è¦–è´è€…ã¨ã—ã¦ç™»éŒ²
    ws.send(JSON.stringify({ viewer: true }));
  };

  ws.onmessage = async (e) => {
    try {
      const msg = JSON.parse(e.data);

      // --- é…ä¿¡çµ‚äº†é€šçŸ¥ ---
      if (msg.broadcasterDisconnected) {
        updateStatus('é…ä¿¡ãŒçµ‚äº†ã—ã¾ã—ãŸ', 'status-error');
        if (pc) {
          pc.close();
          pc = null;
        }
        video.srcObject = null;
        connectBtn.disabled = false;
        return;
      }

      // --- Offerã‚’å—ä¿¡ ---
      if (msg.offer) {
        console.log("ğŸ“¡ Offer received from broadcaster");

        // å¤ã„PeerConnectionãŒæ®‹ã£ã¦ã„ãŸã‚‰é–‰ã˜ã‚‹
        if (pc) {
          try { pc.close(); } catch {}
          pc = null;
        }

        // PeerConnectionã‚’æ–°è¦ä½œæˆ
        pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

        // ãƒªãƒ¢ãƒ¼ãƒˆãƒˆãƒ©ãƒƒã‚¯å—ä¿¡
        pc.ontrack = (e) => {
          console.log("ğŸ Remote track received");
          video.srcObject = e.streams[0];
          video.play().catch((err) => {
            console.warn("âš ï¸ Autoplay blocked:", err);
            updateStatus("å†ç”Ÿãƒ–ãƒ­ãƒƒã‚¯: ã‚¯ãƒªãƒƒã‚¯ã§å†é–‹", "status-error");
          });
          updateStatus("âœ… è¦–è´ä¸­", "status-connected");
        };

        // ICEå€™è£œé€ä¿¡
        pc.onicecandidate = (e) => {
          if (e.candidate && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ candidate: e.candidate }));
          }
        };

        // ICEçŠ¶æ…‹ç›£è¦–
        pc.oniceconnectionstatechange = () => {
          console.log("ICE state:", pc.iceConnectionState);
          if (pc.iceConnectionState === "disconnected" || pc.iceConnectionState === "failed") {
            updateStatus("æ¥ç¶šãŒåˆ‡ã‚Œã¾ã—ãŸ", "status-error");
            video.srcObject = null;
          }
        };

        // Offerè¨­å®š â†’ Answerç”Ÿæˆ
        await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        // Answeré€ä¿¡
        ws.send(JSON.stringify({ answer }));
        connectBtn.disabled = true;
        return;
      }

      // --- ICE candidateã‚’å—ä¿¡ ---
      if (msg.candidate && pc) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
        } catch (err) {
          console.error("âŒ Failed to add ICE candidate:", err);
        }
        return;
      }

      // --- é…ä¿¡å¾…æ©Ÿ ---
      if (msg.waiting) {
        updateStatus("é…ä¿¡å¾…æ©Ÿä¸­...", "status-waiting");
        connectBtn.disabled = false;
        return;
      }

    } catch (err) {
      console.error("âŒ Error handling message:", err);
      updateStatus("ã‚¨ãƒ©ãƒ¼: " + err.message, "status-error");
    }
  };

  ws.onerror = (err) => {
    console.error("WebSocket error:", err);
    updateStatus("æ¥ç¶šã‚¨ãƒ©ãƒ¼", "status-error");
  };

  ws.onclose = () => {
    console.log("ğŸ”Œ WebSocket closed");
    updateStatus("åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ", "status-disconnected");
    connectBtn.disabled = false;

    // å†æ¥ç¶šãƒªãƒˆãƒ©ã‚¤
    if (!reconnectInterval) {
      reconnectInterval = setInterval(() => {
        console.log("ğŸ”„ Attempting to reconnect...");
        connectWebSocket();
      }, 3000);
    }
  };
}

connectBtn.onclick = () => {
  connectWebSocket();
};

// ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
window.addEventListener('beforeunload', () => {
  if (pc) pc.close();
  if (ws) ws.close();
});

// åˆæœŸæ¥ç¶š
connectWebSocket();
</script>
</body>
</html>
