<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>é…ä¿¡è€… | OBS VirtualCam â†’ WebRTC</title>
<style>
  body {
    background: #111;
    color: #eee;
    text-align: center;
    font-family: sans-serif;
    margin: 0;
    padding: 20px;
  }
  #local {
    width: 90%;
    max-width: 800px;
    border-radius: 12px;
    background: #000;
    margin: 20px auto;
  }
  button {
    padding: 12px 30px;
    font-size: 16px;
    border-radius: 8px;
    border: none;
    background: #4CAF50;
    color: white;
    cursor: pointer;
    margin: 10px;
  }
  button:disabled {
    background: #666;
    cursor: not-allowed;
  }
  button:hover:not(:disabled) {
    background: #45a049;
  }
  #stopBtn {
    background: #f44336;
  }
  #stopBtn:hover:not(:disabled) {
    background: #da190b;
  }
  #status {
    margin: 20px;
    padding: 10px;
    border-radius: 8px;
    display: inline-block;
  }
  .status-disconnected { background: #666; }
  .status-connected { background: #2196F3; }
  .status-streaming { background: #4CAF50; }
  .status-error { background: #f44336; }
  .debug-info {
    margin-top: 20px;
    padding: 10px;
    background: #222;
    border-radius: 8px;
    font-size: 12px;
    text-align: left;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
  }
</style>
</head>
<body>
<h1>ğŸ¥ é…ä¿¡è€…ãƒšãƒ¼ã‚¸</h1>
<p>OBSã®ä»®æƒ³ã‚«ãƒ¡ãƒ©ã‚’ONã«ã—ã¦ã€Œé…ä¿¡é–‹å§‹ã€ã‚’ã‚¯ãƒªãƒƒã‚¯</p>

<div id="status" class="status-disconnected">æœªæ¥ç¶š</div>

<video id="local" autoplay playsinline muted></video>

<div>
  <button id="startBtn">é…ä¿¡é–‹å§‹</button>
  <button id="stopBtn" disabled>é…ä¿¡åœæ­¢</button>
</div>

<div style="margin-top: 20px; font-size: 14px; color: #aaa;">
  <p id="viewerCount">è¦–è´è€…: 0äºº</p>
  <p id="connectionState">æ¥ç¶šçŠ¶æ…‹: -</p>
</div>

<div class="debug-info">
  <div><strong>ãƒ‡ãƒãƒƒã‚°æƒ…å ±:</strong></div>
  <div id="debugLog"></div>
</div>

<script>
const WS_URL = "wss://k-divenohtml.onrender.com";

// âœ… TURNã‚µãƒ¼ãƒãƒ¼ã‚’è¿½åŠ ï¼ˆNATè¶Šãˆæ”¹å–„ï¼‰
const ICE_SERVERS = [
  { urls: 'stun:stun.l.google.com:19302' },
  { urls: 'stun:stun1.l.google.com:19302' },
  { urls: 'stun:stun2.l.google.com:19302' },
  // ç„¡æ–™ã®TURNã‚µãƒ¼ãƒãƒ¼ï¼ˆåˆ¶é™ã‚ã‚Šï¼‰
  {
    urls: 'turn:openrelay.metered.ca:80',
    username: 'openrelayproject',
    credential: 'openrelayproject'
  },
  {
    urls: 'turn:openrelay.metered.ca:443',
    username: 'openrelayproject',
    credential: 'openrelayproject'
  }
];

let ws = null;
let pc = null;
let localStream = null;
let reconnectInterval = null;
let connectionTimeout = null;

const statusDiv = document.getElementById('status');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const video = document.getElementById('local');
const debugLog = document.getElementById('debugLog');
const connectionState = document.getElementById('connectionState');

function log(msg) {
  console.log(msg);
  const time = new Date().toLocaleTimeString();
  debugLog.innerHTML = `[${time}] ${msg}<br>` + debugLog.innerHTML;
  // æœ€æ–°20ä»¶ã®ã¿ä¿æŒ
  const lines = debugLog.innerHTML.split('<br>');
  if (lines.length > 20) {
    debugLog.innerHTML = lines.slice(0, 20).join('<br>');
  }
}

function updateStatus(text, className) {
  statusDiv.textContent = text;
  statusDiv.className = className;
}

function connectWebSocket() {
  if (ws && ws.readyState === WebSocket.OPEN) return;
  
  updateStatus('æ¥ç¶šä¸­...', 'status-connected');
  log('ğŸ”„ WebSocketæ¥ç¶šã‚’è©¦è¡Œä¸­...');
  ws = new WebSocket(WS_URL);
  
  ws.onopen = () => {
    log('âœ… WebSocketæ¥ç¶šæˆåŠŸ');
    updateStatus('æ¥ç¶šæ¸ˆã¿ (é…ä¿¡å¾…æ©Ÿä¸­)', 'status-connected');
    if (reconnectInterval) {
      clearInterval(reconnectInterval);
      reconnectInterval = null;
    }
  };
  
  ws.onmessage = async (e) => {
    try {
      const msg = JSON.parse(e.data);
      
      if (msg.answer && pc) {
        log('ğŸ“¥ è¦–è´è€…ã‹ã‚‰Answerã‚’å—ä¿¡');
        await pc.setRemoteDescription(new RTCSessionDescription(msg.answer));
      } else if (msg.candidate && pc) {
        log('ğŸ§Š è¦–è´è€…ã‹ã‚‰ICEå€™è£œã‚’å—ä¿¡');
        await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
      }
    } catch (err) {
      log('âŒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ã‚¨ãƒ©ãƒ¼: ' + err.message);
    }
  };
  
  ws.onerror = (err) => {
    log('âŒ WebSocketã‚¨ãƒ©ãƒ¼');
    updateStatus('æ¥ç¶šã‚¨ãƒ©ãƒ¼', 'status-error');
  };
  
  ws.onclose = () => {
    log('ğŸ”Œ WebSocketåˆ‡æ–­');
    updateStatus('åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ', 'status-disconnected');
    
    // è‡ªå‹•å†æ¥ç¶š
    if (!reconnectInterval) {
      reconnectInterval = setInterval(() => {
        log('ğŸ”„ è‡ªå‹•å†æ¥ç¶šã‚’è©¦è¡Œ...');
        connectWebSocket();
      }, 3000);
    }
  };
}

async function startBroadcast() {
  try {
    log('ğŸ¬ é…ä¿¡é–‹å§‹å‡¦ç†ã‚’é–‹å§‹');
    updateStatus('ã‚«ãƒ¡ãƒ©èµ·å‹•ä¸­...', 'status-connected');
    
    // âœ… ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šï¼ˆ30ç§’ï¼‰
    connectionTimeout = setTimeout(() => {
      log('â±ï¸ æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ30ç§’çµŒéï¼‰');
      updateStatus('æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ', 'status-error');
      alert('æ¥ç¶šãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
      stopBroadcast();
    }, 30000);
    
    // ã‚«ãƒ¡ãƒ©å–å¾—
    localStream = await navigator.mediaDevices.getUserMedia({
      video: {
        width: { ideal: 1280 },
        height: { ideal: 720 },
        frameRate: { ideal: 30 }
      },
      audio: false
    });
    
    log('ğŸ“¹ ã‚«ãƒ¡ãƒ©å–å¾—æˆåŠŸ');
    video.srcObject = localStream;
    
    // PeerConnectionä½œæˆ
    pc = new RTCPeerConnection({ 
      iceServers: ICE_SERVERS,
      // âœ… æ¥ç¶šè¨­å®šã®æœ€é©åŒ–
      iceCandidatePoolSize: 10,
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    });
    log('ğŸ”— PeerConnectionä½œæˆ');
    
    // ãƒˆãƒ©ãƒƒã‚¯è¿½åŠ 
    localStream.getTracks().forEach(track => {
      pc.addTrack(track, localStream);
      log(`â• ãƒˆãƒ©ãƒƒã‚¯è¿½åŠ : ${track.kind}`);
    });
    
    // ICEå€™è£œã®å‡¦ç†
    let iceCandidateCount = 0;
    pc.onicecandidate = (e) => {
      if (e.candidate && ws && ws.readyState === WebSocket.OPEN) {
        iceCandidateCount++;
        log(`ğŸ§Š ICEå€™è£œé€ä¿¡ #${iceCandidateCount}`);
        ws.send(JSON.stringify({ candidate: e.candidate }));
      } else if (!e.candidate) {
        log('âœ… ICEå€™è£œã®åé›†å®Œäº†');
      }
    };
    
    pc.oniceconnectionstatechange = () => {
      const state = pc.iceConnectionState;
      log(`ğŸ”„ ICEæ¥ç¶šçŠ¶æ…‹: ${state}`);
      connectionState.textContent = `æ¥ç¶šçŠ¶æ…‹: ${state}`;
      
      if (state === 'connected' || state === 'completed') {
        updateStatus('ğŸ”´ é…ä¿¡ä¸­', 'status-streaming');
        if (connectionTimeout) {
          clearTimeout(connectionTimeout);
          connectionTimeout = null;
        }
      } else if (state === 'disconnected') {
        updateStatus('ä¸€æ™‚çš„ã«åˆ‡æ–­', 'status-error');
      } else if (state === 'failed') {
        log('âŒ ICEæ¥ç¶šå¤±æ•—');
        updateStatus('æ¥ç¶šå¤±æ•—', 'status-error');
      }
    };
    
    // âœ… æ¥ç¶šå“è³ªã®ç›£è¦–
    pc.onconnectionstatechange = () => {
      log(`ğŸ”„ PeerConnectionçŠ¶æ…‹: ${pc.connectionState}`);
    };
    
    // Offerä½œæˆ
    log('ğŸ“ Offerä½œæˆä¸­...');
    const offer = await pc.createOffer({
      offerToReceiveVideo: false,
      offerToReceiveAudio: false
    });
    await pc.setLocalDescription(offer);
    log('âœ… LocalDescriptionè¨­å®šå®Œäº†');
    
    // Offerã‚’é€ä¿¡
    if (ws && ws.readyState === WebSocket.OPEN) {
      log('ğŸ“¤ Offerã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡');
      ws.send(JSON.stringify({ offer }));
      updateStatus('é…ä¿¡æº–å‚™å®Œäº† (è¦–è´è€…å¾…ã¡)', 'status-streaming');
    } else {
      throw new Error('WebSocketæ¥ç¶šãŒã‚ã‚Šã¾ã›ã‚“');
    }
    
    startBtn.disabled = true;
    stopBtn.disabled = false;
    
  } catch (err) {
    log('âŒ é…ä¿¡é–‹å§‹ã‚¨ãƒ©ãƒ¼: ' + err.message);
    updateStatus('ã‚¨ãƒ©ãƒ¼: ' + err.message, 'status-error');
    alert('ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\nOBSã®ä»®æƒ³ã‚«ãƒ¡ãƒ©ãŒONã«ãªã£ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚\nä»–ã®ã‚¢ãƒ—ãƒªã§ã‚«ãƒ¡ãƒ©ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„ã‹ã‚‚ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
    stopBroadcast();
  }
}

function stopBroadcast() {
  log('ğŸ›‘ é…ä¿¡åœæ­¢');
  
  if (connectionTimeout) {
    clearTimeout(connectionTimeout);
    connectionTimeout = null;
  }
  
  // ã‚¹ãƒˆãƒªãƒ¼ãƒ åœæ­¢
  if (localStream) {
    localStream.getTracks().forEach(track => {
      track.stop();
      log(`â¹ï¸ ãƒˆãƒ©ãƒƒã‚¯åœæ­¢: ${track.kind}`);
    });
    localStream = null;
  }
  
  // PeerConnectionçµ‚äº†
  if (pc) {
    pc.close();
    pc = null;
  }
  
  video.srcObject = null;
  updateStatus('é…ä¿¡åœæ­¢', 'status-connected');
  connectionState.textContent = 'æ¥ç¶šçŠ¶æ…‹: -';
  
  startBtn.disabled = false;
  stopBtn.disabled = true;
}

startBtn.onclick = startBroadcast;
stopBtn.onclick = stopBroadcast;

// ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
window.addEventListener('beforeunload', () => {
  stopBroadcast();
  if (ws) ws.close();
});

// åˆæœŸæ¥ç¶š
connectWebSocket();
log('ğŸš€ é…ä¿¡è€…ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†');
</script>
</body>
</html>
