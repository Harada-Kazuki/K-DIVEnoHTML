<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ÈÖç‰ø°ËÄÖ | OBS VirtualCam ‚Üí WebRTC</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    background: #0a0a0a;
    color: #d4c5aa;
    font-family: 'Orbitron', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 30px 20px;
    position: relative;
    overflow-x: hidden;
  }
  
  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      linear-gradient(90deg, transparent 0%, rgba(212, 197, 170, 0.03) 50%, transparent 100%),
      repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(212, 197, 170, 0.05) 2px, rgba(212, 197, 170, 0.05) 4px);
    pointer-events: none;
    z-index: 0;
  }
  
  .container {
    position: relative;
    z-index: 1;
    max-width: 1000px;
    width: 100%;
  }
  
  h1 {
    font-size: 2.5em;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 4px;
    margin-bottom: 10px;
    text-shadow: 0 0 20px rgba(212, 197, 170, 0.5);
    border-left: 4px solid #d4c5aa;
    padding-left: 20px;
  }
  
  .subtitle {
    font-size: 0.9em;
    color: #8a8174;
    margin-bottom: 30px;
    padding-left: 24px;
    letter-spacing: 2px;
  }
  
  #status {
    display: inline-block;
    padding: 12px 30px;
    margin: 20px 0;
    border: 2px solid #d4c5aa;
    background: rgba(10, 10, 10, 0.8);
    font-size: 0.9em;
    letter-spacing: 2px;
    text-transform: uppercase;
    position: relative;
    clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
  }
  
  .status-disconnected { 
    border-color: #555;
    color: #555;
  }
  .status-connected { 
    border-color: #5ac8fa;
    color: #5ac8fa;
    box-shadow: 0 0 20px rgba(90, 200, 250, 0.3);
  }
  .status-connecting { 
    border-color: #ff9f43;
    color: #ff9f43;
    box-shadow: 0 0 20px rgba(255, 159, 67, 0.3);
    animation: pulse 1.5s infinite;
  }
  .status-streaming { 
    border-color: #d4c5aa;
    color: #d4c5aa;
    box-shadow: 0 0 20px rgba(212, 197, 170, 0.4);
    animation: pulse 2s infinite;
  }
  .status-error { 
    border-color: #ff6b6b;
    color: #ff6b6b;
    box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }
  
  #local {
    width: 100%;
    max-width: 900px;
    background: #000;
    margin: 30px auto;
    border: 3px solid #d4c5aa;
    box-shadow: 
      0 0 30px rgba(212, 197, 170, 0.2),
      inset 0 0 50px rgba(0, 0, 0, 0.5);
    clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
  }
  
  .controls {
    display: flex;
    gap: 20px;
    justify-content: center;
    margin: 30px 0;
    flex-wrap: wrap;
  }
  
  button {
    padding: 15px 40px;
    font-size: 0.95em;
    font-family: 'Orbitron', monospace;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
    border: 2px solid #d4c5aa;
    background: rgba(10, 10, 10, 0.9);
    color: #d4c5aa;
    cursor: pointer;
    transition: all 0.3s;
    clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
    position: relative;
  }
  
  button::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, transparent, rgba(212, 197, 170, 0.2), transparent);
    clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
    opacity: 0;
    transition: opacity 0.3s;
    z-index: -1;
  }
  
  button:hover:not(:disabled)::before {
    opacity: 1;
  }
  
  button:hover:not(:disabled) {
    background: rgba(212, 197, 170, 0.1);
    box-shadow: 0 0 20px rgba(212, 197, 170, 0.3);
    transform: translateY(-2px);
  }
  
  button:disabled {
    border-color: #333;
    color: #333;
    cursor: not-allowed;
    background: rgba(10, 10, 10, 0.5);
  }
  
  #stopBtn {
    border-color: #ff6b6b;
    color: #ff6b6b;
  }
  
  #stopBtn:hover:not(:disabled) {
    background: rgba(255, 107, 107, 0.1);
    box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
  }
  
  .info-panel {
    display: flex;
    gap: 30px;
    justify-content: center;
    margin: 20px 0;
    flex-wrap: wrap;
  }
  
  .info-item {
    padding: 10px 20px;
    border-left: 3px solid #d4c5aa;
    background: rgba(212, 197, 170, 0.05);
    font-size: 0.9em;
    letter-spacing: 1px;
  }
  
  .debug-info {
    margin-top: 40px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid #333;
    font-size: 11px;
    text-align: left;
    max-width: 900px;
    margin-left: auto;
    margin-right: auto;
    font-family: 'Courier New', monospace;
    color: #8a8174;
    clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
    max-height: 300px;
    overflow-y: auto;
  }
  
  .debug-info::-webkit-scrollbar {
    width: 8px;
  }
  
  .debug-info::-webkit-scrollbar-track {
    background: #0a0a0a;
  }
  
  .debug-info::-webkit-scrollbar-thumb {
    background: #333;
    border-radius: 4px;
  }
  
  .debug-info strong {
    color: #d4c5aa;
    font-size: 12px;
    letter-spacing: 2px;
    display: block;
    margin-bottom: 10px;
  }
</style>
</head>
<body>
<div class="container">
  <h1>üé• Broadcaster</h1>
  <p class="subtitle">OBS Virtual Camera Stream</p>

  <div id="status" class="status-disconnected">System Offline</div>

  <video id="local" autoplay playsinline muted></video>

  <div class="controls">
    <button id="startBtn">Start Broadcast</button>
    <button id="stopBtn" disabled>Stop Broadcast</button>
  </div>

  <div class="info-panel">
    <div class="info-item" id="viewerCount">Viewers: 0</div>
  </div>

  <div class="debug-info">
    <strong>// System Log</strong>
    <div id="debugLog"></div>
  </div>
</div>

<script>
const WS_URL = "wss://k-divenohtml.onrender.com";

const ICE_SERVERS = [
  { urls: 'stun:stun.l.google.com:19302' },
  { urls: 'stun:stun1.l.google.com:19302' },
  { urls: 'stun:stun2.l.google.com:19302' },
  {
    urls: 'turn:openrelay.metered.ca:80',
    username: 'openrelayproject',
    credential: 'openrelayproject'
  },
  {
    urls: 'turn:openrelay.metered.ca:443',
    username: 'openrelayproject',
    credential: 'openrelayproject'
  }
];

let ws = null;
let localStream = null;
let reconnectInterval = null;
const peerConnections = new Map();
let isStreaming = false;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 10;
let isIntentionalDisconnect = false;

const statusDiv = document.getElementById('status');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const video = document.getElementById('local');
const debugLog = document.getElementById('debugLog');
const viewerCount = document.getElementById('viewerCount');

function log(msg) {
  console.log(msg);
  const time = new Date().toLocaleTimeString();
  debugLog.innerHTML = `[${time}] ${msg}<br>` + debugLog.innerHTML;
  const lines = debugLog.innerHTML.split('<br>');
  if (lines.length > 30) {
    debugLog.innerHTML = lines.slice(0, 30).join('<br>');
  }
}

function updateStatus(text, className) {
  const statusMap = {
    'Êé•Á∂ö‰∏≠...': 'Connecting...',
    'Êé•Á∂öÊ∏à„Åø (ÈÖç‰ø°ÂæÖÊ©ü‰∏≠)': 'Standby Mode',
    '„Ç´„É°„É©Ëµ∑Âãï‰∏≠...': 'Camera Initializing...',
    'ÈÖç‰ø°Ê∫ñÂÇôÂÆå‰∫Ü': 'Ready to Broadcast',
    'ÈÖç‰ø°Âæ©Êóß‰∏≠...': 'Restoring Broadcast...',
    'ÂÜçÊé•Á∂ö‰∏≠...': 'Reconnecting...',
    'üî¥ ÈÖç‰ø°‰∏≠': '[ LIVE ]',
    'ÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü': 'Connection Lost',
    'ÈÖç‰ø°ÂÅúÊ≠¢': 'Broadcast Ended',
    'Êé•Á∂ö„Ç®„É©„Éº': 'Connection Error',
    'ÂÜçÊé•Á∂öÂ§±Êïó': 'Reconnection Failed'
  };
  statusDiv.textContent = statusMap[text] || text;
  statusDiv.className = className;
}

function updateViewerCount() {
  viewerCount.textContent = `Viewers: ${peerConnections.size}`;
}

function connectWebSocket() {
  if (ws && ws.readyState === WebSocket.OPEN) return;
  
  updateStatus('Êé•Á∂ö‰∏≠...', 'status-connecting');
  log('üîÑ WebSocketÊé•Á∂ö„ÇíË©¶Ë°å‰∏≠...');
  ws = new WebSocket(WS_URL);
  
  ws.onopen = () => {
    log('‚úÖ WebSocketÊé•Á∂öÊàêÂäü');
    reconnectAttempts = 0;
    
    if (reconnectInterval) {
      clearInterval(reconnectInterval);
      reconnectInterval = null;
    }
    
    ws.send(JSON.stringify({ broadcaster: true }));
    
    if (localStream) {
      log('üîÑ ÈÖç‰ø°‰∏≠„ÅÆÂÜçÊé•Á∂ö - Êó¢Â≠òË¶ñËÅ¥ËÄÖ„Å®„ÅÆÊé•Á∂ö„ÇíÂæ©Êóß„Åó„Åæ„Åô');
      updateStatus('ÈÖç‰ø°Âæ©Êóß‰∏≠...', 'status-streaming');
    } else {
      updateStatus('Êé•Á∂öÊ∏à„Åø (ÈÖç‰ø°ÂæÖÊ©ü‰∏≠)', 'status-connected');
    }
  };
  
  ws.onmessage = async (e) => {
    try {
      const msg = JSON.parse(e.data);
      
      if (msg.type === 'newViewer') {
        log(`üë§ Êñ∞„Åó„ÅÑË¶ñËÅ¥ËÄÖ: ${msg.viewerId}`);
        if (localStream) {
          await createPeerConnection(msg.viewerId);
        } else {
          log('‚ö†Ô∏è „É≠„Éº„Ç´„É´„Çπ„Éà„É™„Éº„É†„Åå„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÈÖç‰ø°ÈñãÂßãÂæå„Å´ÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        }
      }
      
      else if (msg.type === 'answer') {
        log(`üì• Ë¶ñËÅ¥ËÄÖ ${msg.viewerId} „Åã„ÇâAnswer„ÇíÂèó‰ø°`);
        const pc = peerConnections.get(msg.viewerId);
        if (pc) {
          await pc.setRemoteDescription(new RTCSessionDescription(msg.answer));
          log(`‚úÖ Ë¶ñËÅ¥ËÄÖ ${msg.viewerId} „Å®„ÅÆ„Éç„Ç¥„Ç∑„Ç®„Éº„Ç∑„Éß„É≥ÂÆå‰∫Ü`);
        }
      }
      
      else if (msg.type === 'candidate') {
        const pc = peerConnections.get(msg.viewerId);
        if (pc && msg.candidate) {
          log(`üßä Ë¶ñËÅ¥ËÄÖ ${msg.viewerId} „Åã„ÇâICEÂÄôË£ú„ÇíÂèó‰ø°`);
          await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
        }
      }
      
      else if (msg.type === 'viewerDisconnected') {
        log(`üëã Ë¶ñËÅ¥ËÄÖ ${msg.viewerId} „ÅåÂàáÊñ≠`);
        const pc = peerConnections.get(msg.viewerId);
        if (pc) {
          pc.close();
          peerConnections.delete(msg.viewerId);
          updateViewerCount();
        }
      }
      
      else if (msg.type === 'registered' && msg.role === 'broadcaster') {
        log('‚úÖ ÈÖç‰ø°ËÄÖ„Å®„Åó„Å¶ÁôªÈå≤ÂÆå‰∫Ü');
        
        if (msg.existingViewers && msg.existingViewers.length > 0) {
          log(`üìã Êó¢Â≠ò„ÅÆË¶ñËÅ¥ËÄÖ„ÇíÊ§úÂá∫: ${msg.existingViewers.length}‰∫∫`);
          
          if (localStream) {
            log('üîÑ ÈÖç‰ø°‰∏≠„ÅÆÂÜçÊé•Á∂ö - Ë¶ñËÅ¥ËÄÖ„Å®„ÅÆÊé•Á∂ö„ÇíÂÜçÊßãÁØâ„Åó„Åæ„Åô');
            
            peerConnections.forEach((pc, viewerId) => {
              if (pc.connectionState !== 'connected') {
                pc.close();
                peerConnections.delete(viewerId);
                log(`üßπ Âè§„ÅÑÊé•Á∂ö„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó: ${viewerId}`);
              }
            });
            
            for (const viewerId of msg.existingViewers) {
              setTimeout(async () => {
                await createPeerConnection(viewerId);
              }, 100);
            }
            
            updateStatus('üî¥ ÈÖç‰ø°‰∏≠', 'status-streaming');
          } else {
            window.existingViewers = msg.existingViewers;
          }
        }
      }
      
    } catch (err) {
      log('‚ùå „É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜ„Ç®„É©„Éº: ' + err.message);
    }
  };
  
  ws.onerror = (err) => {
    log('‚ùå WebSocket„Ç®„É©„Éº');
    updateStatus('Êé•Á∂ö„Ç®„É©„Éº', 'status-error');
  };
  
  ws.onclose = () => {
    log('üîå WebSocketÂàáÊñ≠');
    
    if (isIntentionalDisconnect) {
      updateStatus('ÈÖç‰ø°ÂÅúÊ≠¢', 'status-disconnected');
      log('‚úÖ ÈÖç‰ø°„ÇíÊ≠£Â∏∏„Å´ÂÅúÊ≠¢„Åó„Åæ„Åó„Åü');
      return;
    }
    
    if (localStream) {
      updateStatus('ÂÜçÊé•Á∂ö‰∏≠...', 'status-connecting');
      log('‚ö†Ô∏è ÈÖç‰ø°‰∏≠„Å´ÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü - Ëá™ÂãïÂÜçÊé•Á∂ö„Åó„Åæ„Åô');
      
      if (!reconnectInterval) {
        reconnectInterval = setInterval(() => {
          if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            reconnectAttempts++;
            log(`üîÑ Ëá™ÂãïÂÜçÊé•Á∂ö„ÇíË©¶Ë°å... (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
            connectWebSocket();
          } else {
            clearInterval(reconnectInterval);
            reconnectInterval = null;
            log('‚ùå ÊúÄÂ§ßÂÜçÊé•Á∂öÂõûÊï∞„Å´ÈÅî„Åó„Åæ„Åó„Åü');
            updateStatus('ÂÜçÊé•Á∂öÂ§±Êïó', 'status-error');
          }
        }, 3000);
      }
    } else {
      updateStatus('ÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü', 'status-disconnected');
    }
  };
}

async function createPeerConnection(viewerId) {
  try {
    log(`üîó Ë¶ñËÅ¥ËÄÖ ${viewerId} Áî®„ÅÆPeerConnection‰ΩúÊàê`);
    
    const pc = new RTCPeerConnection({ 
      iceServers: ICE_SERVERS,
      iceCandidatePoolSize: 10,
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    });
    
    localStream.getTracks().forEach(track => {
      pc.addTrack(track, localStream);
      log(`‚ûï Ë¶ñËÅ¥ËÄÖ ${viewerId} „Å´„Éà„É©„ÉÉ„ÇØËøΩÂä†: ${track.kind}`);
    });
    
    pc.onicecandidate = (e) => {
      if (e.candidate && ws && ws.readyState === WebSocket.OPEN) {
        log(`üßä Ë¶ñËÅ¥ËÄÖ ${viewerId} Áî®„ÅÆICEÂÄôË£úÈÄÅ‰ø°`);
        ws.send(JSON.stringify({ 
          candidate: e.candidate,
          targetViewerId: viewerId
        }));
      }
    };
    
    pc.oniceconnectionstatechange = () => {
      log(`üîÑ Ë¶ñËÅ¥ËÄÖ ${viewerId} „ÅÆICEÁä∂ÊÖã: ${pc.iceConnectionState}`);
      if (pc.iceConnectionState === 'connected') {
        updateStatus('üî¥ ÈÖç‰ø°‰∏≠', 'status-streaming');
      } else if (pc.iceConnectionState === 'failed') {
        log(`‚ùå Ë¶ñËÅ¥ËÄÖ ${viewerId} „Å®„ÅÆÊé•Á∂öÂ§±Êïó`);
        pc.close();
        peerConnections.delete(viewerId);
        updateViewerCount();
      }
    };
    
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    log(`‚úÖ Ë¶ñËÅ¥ËÄÖ ${viewerId} Áî®„ÅÆOffer‰ΩúÊàêÂÆå‰∫Ü`);
    
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ 
        offer,
        targetViewerId: viewerId
      }));
      log(`üì§ Ë¶ñËÅ¥ËÄÖ ${viewerId} „Å´OfferÈÄÅ‰ø°`);
    }
    
    peerConnections.set(viewerId, pc);
    updateViewerCount();
    
  } catch (err) {
    log(`‚ùå Ë¶ñËÅ¥ËÄÖ ${viewerId} „ÅÆÊé•Á∂ö„Ç®„É©„Éº: ${err.message}`);
  }
}

async function startBroadcast() {
  try {
    log('üé¨ ÈÖç‰ø°ÈñãÂßãÂá¶ÁêÜ„ÇíÈñãÂßã');
    updateStatus('„Ç´„É°„É©Ëµ∑Âãï‰∏≠...', 'status-connecting');
    
    localStream = await navigator.mediaDevices.getUserMedia({
      video: {
        width: { ideal: 1280 },
        height: { ideal: 720 },
        frameRate: { ideal: 30 }
      },
      audio: false
    });
    
    log('üìπ „Ç´„É°„É©ÂèñÂæóÊàêÂäü');
    video.srcObject = localStream;
    
    updateStatus('ÈÖç‰ø°Ê∫ñÂÇôÂÆå‰∫Ü', 'status-streaming');
    startBtn.disabled = true;
    stopBtn.disabled = false;
    
    if (window.existingViewers && window.existingViewers.length > 0) {
      log(`üîÑ Êó¢Â≠ò„ÅÆË¶ñËÅ¥ËÄÖ„Å´ÂÜçÊé•Á∂ö‰∏≠: ${window.existingViewers.length}‰∫∫`);
      for (const viewerId of window.existingViewers) {
        await createPeerConnection(viewerId);
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      window.existingViewers = null;
    }
    
  } catch (err) {
    log('‚ùå ÈÖç‰ø°ÈñãÂßã„Ç®„É©„Éº: ' + err.message);
    updateStatus('„Ç®„É©„Éº: ' + err.message, 'status-error');
    alert('„Ç´„É°„É©„ÅÆËµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ\n\nOBS„ÅÆ‰ªÆÊÉ≥„Ç´„É°„É©„ÅåON„Å´„Å™„Å£„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
  }
}

function stopBroadcast() {
  log('üõë ÈÖç‰ø°ÂÅúÊ≠¢');
  isIntentionalDisconnect = true;
  
  peerConnections.forEach((pc, viewerId) => {
    pc.close();
    log(`‚èπÔ∏è Ë¶ñËÅ¥ËÄÖ ${viewerId} „Å®„ÅÆÊé•Á∂ö„ÇíÁµÇ‰∫Ü`);
  });
  peerConnections.clear();
  updateViewerCount();
  
  if (localStream) {
    localStream.getTracks().forEach(track => {
      track.stop();
      log(`‚èπÔ∏è „Éà„É©„ÉÉ„ÇØÂÅúÊ≠¢: ${track.kind}`);
    });
    localStream = null;
  }
  
  video.srcObject = null;
  
  if (ws) {
    ws.close();
    ws = null;
  }
  
  if (reconnectInterval) {
    clearInterval(reconnectInterval);
    reconnectInterval = null;
  }
  
  updateStatus('ÈÖç‰ø°ÂÅúÊ≠¢', 'status-disconnected');
  startBtn.disabled = false;
  stopBtn.disabled = true;
  
  setTimeout(() => {
    isIntentionalDisconnect = false;
  }, 1000);
}

startBtn.onclick = startBroadcast;
stopBtn.onclick = stopBroadcast;

window.addEventListener('beforeunload', () => {
  isIntentionalDisconnect = true;
  stopBroadcast();
});

connectWebSocket();
log('üöÄ ÈÖç‰ø°ËÄÖ„Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü');
</script>
</body>
</html>
